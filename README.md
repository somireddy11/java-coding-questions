# java-coding-questions

Sure! Below is a coding question related to Java collections:

### Problem Statement: **Find the Most Frequent Element in a List**

**Description**: Given a list of integers, find the element that appears the most in the list. If there is a tie (i.e., multiple elements appear the same maximum number of times), return the smallest of these elements.

**For example**:
- Input: `[4, 5, 6, 4, 4, 5, 5, 7]`
- Output: `4`

**Input**:
- A list of integers `nums`.

**Output**:
- The element that occurs the most in the list. If multiple elements have the same frequency, return the smallest one.

### Approach:

1. **Use a HashMap** to store the frequency of each element.
2. **Iterate through the list** and populate the HashMap with the count of each element.
3. **Identify the maximum frequency** and then check for the element(s) with that frequency.
4. If multiple elements have the same frequency, return the smallest one.

---
Here are five more LeetCode problems that can be solved using Java Collections, with varying levels of difficulty:

### 1. **Valid Anagram** (Easy)

**Problem Description:**
Given two strings `s` and `t`, return `true` if `t` is an anagram of `s` and `false` otherwise.

An **Anagram** is a word or phrase formed by rearranging the letters of another.

**Example 1:**
```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**
```
Input: s = "rat", t = "car"
Output: false
```

**Solution Approach:**
- Count the frequency of characters in both strings using `HashMap` or `int[]` for a more efficient solution.

```java
import java.util.*;

public class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] count = new int[26];  // assuming only lowercase letters
        for (char c : s.toCharArray()) count[c - 'a']++;
        for (char c : t.toCharArray()) count[c - 'a']--;
        
        for (int i : count) {
            if (i != 0) return false;
        }
        
        return true;
    }
}
```

---

### 2. **Contains Duplicate** (Easy)

**Problem Description:**
Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**
```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**
```
Input: nums = [1,2,3,4]
Output: false
```

**Solution Approach:**
- Use a `HashSet` to check for duplicates.

```java
import java.util.*;

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (!set.add(num)) {
                return true;
            }
        }
        return false;
    }
}
```

---

### 3. **Group Anagrams** (Medium)

**Problem Description:**
Given an array of strings, group the anagrams together. You can return the answer in any order.

**Example 1:**
```
Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]
```

**Solution Approach:**
- Use a `HashMap` where the key is the sorted version of the string, and the value is a list of strings that are anagrams of each other.

```java
import java.util.*;

public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String sorted = new String(chars);
            map.putIfAbsent(sorted, new ArrayList<>());
            map.get(sorted).add(str);
        }
        return new ArrayList<>(map.values());
    }
}
```

---

### 4. **Find the Difference** (Easy)

**Problem Description:**
You are given two strings `s` and `t`. String `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Find the letter that was added.

**Example 1:**
```
Input: s = "abcd", t = "abcde"
Output: "e"
```

**Example 2:**
```
Input: s = "", t = "y"
Output: "y"
```

**Solution Approach:**
- Use a `HashMap` or `int[]` to count the frequency of characters in both strings and find the difference.

```java
import java.util.*;

public class Solution {
    public char findTheDifference(String s, String t) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) count[c - 'a']++;
        for (char c : t.toCharArray()) {
            if (--count[c - 'a'] < 0) return c;
        }
        return ' ';  // this line won't be reached because there's always a difference
    }
}
```

---

### 5. **Top K Frequent Words** (Medium)

**Problem Description:**
Given a list of words and an integer `k`, return the `k` most frequent words in the list.

Return the answer sorted by frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.

**Example 1:**
```
Input: words = ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
```

**Solution Approach:**
- Use a `HashMap` to count the frequency of each word, then use a `PriorityQueue` to store the top `k` frequent words.

```java
import java.util.*;

public class Solution {
    public List<String> topKFrequent(String[] words, int k) {
        Map<String, Integer> countMap = new HashMap<>();
        for (String word : words) {
            countMap.put(word, countMap.getOrDefault(word, 0) + 1);
        }
        
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(
            (a, b) -> a.getValue() == b.getValue() ? a.getKey().compareTo(b.getKey()) : b.getValue() - a.getValue()
        );
        
        for (Map.Entry<String, Integer> entry : countMap.entrySet()) {
            pq.offer(entry);
        }
        
        List<String> result = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            result.add(pq.poll().getKey());
        }
        return result;
    }
}
```

---

### Summary:

1. **Valid Anagram**: Use a frequency map (e.g., `int[]` or `HashMap`) to compare the character counts.
2. **Contains Duplicate**: Use a `HashSet` to track seen elements.
3. **Group Anagrams**: Sort each string and use a `HashMap` to group them by the sorted string.
4. **Find the Difference**: Use a frequency count and check for the difference between the two strings.
5. **Top K Frequent Words**: Use a `HashMap` for frequency counting and a `PriorityQueue` for retrieving the most frequent words in sorted order.

These problems allow you to practice using Java collections like `HashMap`, `HashSet`, `PriorityQueue`, and `ArrayList` for common tasks such as grouping, sorting, and finding frequency distributions.
### Solution:

```java
import java.util.*;

public class MostFrequentElement {
    public static int findMostFrequent(List<Integer> nums) {
        // Step 1: Create a HashMap to store the frequency of each element
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        
        // Step 2: Populate the frequency map
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // Step 3: Find the element with the highest frequency and handle ties
        int mostFrequentElement = nums.get(0); // Start with the first element
        int maxFrequency = frequencyMap.get(mostFrequentElement);

        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            int currentElement = entry.getKey();
            int currentFrequency = entry.getValue();

            if (currentFrequency > maxFrequency || (currentFrequency == maxFrequency && currentElement < mostFrequentElement)) {
                mostFrequentElement = currentElement;
                maxFrequency = currentFrequency;
            }
        }

        return mostFrequentElement;
    }

    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(4, 5, 6, 4, 4, 5, 5, 7);
        System.out.println("Most frequent element: " + findMostFrequent(nums)); // Output: 4
    }
}
```

---

### Explanation of the Solution:

1. **Frequency Map (HashMap)**: We use a `HashMap<Integer, Integer>` to store each element as the key and its frequency (count) as the value.
   
2. **Populating the Frequency Map**: We loop through each element of the list, and for each element, we update its count in the `frequencyMap`. We use the `getOrDefault` method to return the current count or `0` if the element does not exist in the map yet.

3. **Finding the Most Frequent Element**:
   - We iterate through the entries of the map.
   - For each entry, if the current frequency is higher than the `maxFrequency`, we update the `mostFrequentElement` to this one.
   - If the current frequency is equal to `maxFrequency`, we check if the current element is smaller than the `mostFrequentElement` and update it if needed (to handle ties).

4. **Time Complexity**:
   - **Time complexity**: O(n), where `n` is the size of the input list, because we iterate over the list once to populate the map and once over the map entries to find the result.
   - **Space complexity**: O(n), where `n` is the size of the input list, as we store the frequencies of all elements in the map.

---

### Test Cases:

**Test Case 1**:
```java
List<Integer> nums = Arrays.asList(4, 5, 6, 4, 4, 5, 5, 7);
System.out.println(findMostFrequent(nums)); // Output: 4
```

**Test Case 2**:
```java
List<Integer> nums = Arrays.asList(1, 1, 2, 2, 3, 3);
System.out.println(findMostFrequent(nums)); // Output: 1 (since 1 and 2 have the same frequency, but 1 is smaller)
```

**Test Case 3**:
```java
List<Integer> nums = Arrays.asList(10, 20, 30, 20, 10, 10);
System.out.println(findMostFrequent(nums)); // Output: 10
```

---

Let me know if you would like to explore any variations of this problem or if you have any other questions!


2. Find the Intersection of Two Lists
Problem: Given two lists of integers, find the intersection of both lists. Each element in the intersection should appear only once, and the result should be a list containing all the common elements.

Example:

Input: list1 = [1, 2, 2, 1], list2 = [2, 2]
Output: [2]
Approach:
Use HashSet to remove duplicates and find the common elements between the two

import java.util.*;

public class ListIntersection {
    public static List<Integer> intersection(List<Integer> list1, List<Integer> list2) {
        Set<Integer> set1 = new HashSet<>(list1);
        Set<Integer> result = new HashSet<>();

        for (int num : list2) {
            if (set1.contains(num)) {
                result.add(num);
            }
        }

        return new ArrayList<>(result);
    }

    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 2, 1);
        List<Integer> list2 = Arrays.asList(2, 2);
        System.out.println(intersection(list1, list2)); // Output: [2]
    }
}

Certainly! Here are some more Java collections-related coding questions to test your understanding and problem-solving skills.

### 1. **Find the Intersection of Two Lists**
**Problem**: 
Given two lists of integers, find the intersection of both lists. Each element in the intersection should appear only once, and the result should be a list containing all the common elements.

**Example**:
- Input: `list1 = [1, 2, 2, 1]`, `list2 = [2, 2]`
- Output: `[2]`

### Approach:
- Use `HashSet` to remove duplicates and find the common elements between the two sets.
  
**Solution**:
```java
import java.util.*;

public class ListIntersection {
    public static List<Integer> intersection(List<Integer> list1, List<Integer> list2) {
        Set<Integer> set1 = new HashSet<>(list1);
        Set<Integer> result = new HashSet<>();

        for (int num : list2) {
            if (set1.contains(num)) {
                result.add(num);
            }
        }

        return new ArrayList<>(result);
    }

    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 2, 1);
        List<Integer> list2 = Arrays.asList(2, 2);
        System.out.println(intersection(list1, list2)); // Output: [2]
    }
}
```

---

### 2. **Merge Two Sorted Lists**
**Problem**:
Given two sorted lists, merge them into one sorted list.

**Example**:
- Input: `list1 = [1, 2, 4]`, `list2 = [1, 3, 4]`
- Output: `[1, 1, 2, 3, 4, 4]`

### Approach:
- Use a two-pointer technique to merge both lists while maintaining the sorted order.

**Solution**:
```java
import java.util.*;

public class MergeSortedLists {
    public static List<Integer> mergeSorted(List<Integer> list1, List<Integer> list2) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;

        while (i < list1.size() && j < list2.size()) {
            if (list1.get(i) <= list2.get(j)) {
                result.add(list1.get(i));
                i++;
            } else {
                result.add(list2.get(j));
                j++;
            }
        }

        // Add remaining elements
        while (i < list1.size()) {
            result.add(list1.get(i));
            i++;
        }

        while (j < list2.size()) {
            result.add(list2.get(j));
            j++;
        }

        return result;
    }

    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 4);
        List<Integer> list2 = Arrays.asList(1, 3, 4);
        System.out.println(mergeSorted(list1, list2)); // Output: [1, 1, 2, 3, 4, 4]
    }
}
```

---

### 3. **Remove Duplicates from a List**
**Problem**:
Given a list of integers, remove all duplicate values from the list.

**Example**:
- Input: `[1, 2, 2, 3, 4, 4]`
- Output: `[1, 2, 3, 4]`

### Approach:
- Use a `HashSet` to remove duplicates because sets do not allow duplicate elements.

**Solution**:
```java
import java.util.*;

public class RemoveDuplicates {
    public static List<Integer> removeDuplicates(List<Integer> list) {
        Set<Integer> set = new HashSet<>(list);
        return new ArrayList<>(set);
    }

    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 2, 3, 4, 4);
        System.out.println(removeDuplicates(list)); // Output: [1, 2, 3, 4]
    }
}
```

---

### 4. **Find the Kth Largest Element in an Array**
**Problem**:
Given an array of integers, find the `K`th largest element in the array.

**Example**:
- Input: `arr = [3, 2, 1, 5, 6, 4]`, `K = 2`
- Output: `5`

### Approach:
- Use a `PriorityQueue` (min-heap) to keep track of the top `K` elements.

**Solution**:
```java
import java.util.*;

public class KthLargestElement {
    public static int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int num : nums) {
            minHeap.add(num);
            if (minHeap.size() > k) {
                minHeap.poll();  // Remove the smallest element when size exceeds k
            }
        }

        return minHeap.peek();  // The root of the min-heap is the kth largest element
    }

    public static void main(String[] args) {
        int[] nums = {3, 2, 1, 5, 6, 4};
        int k = 2;
        System.out.println(findKthLargest(nums, k)); // Output: 5
    }
}
```

---

### 5. **Group Anagrams**
**Problem**:
Given a list of strings, group the anagrams together. An anagram is a word formed by rearranging the letters of another word.

**Example**:
- Input: `["eat", "tea", "tan", "ate", "nat", "bat"]`
- Output: `[["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]`

### Approach:
- Use a `Map` to group words by their sorted characters as the key.

**Solution**:
```java
import java.util.*;

public class GroupAnagrams {
    public static List<List<String>> groupAnagrams(List<String> strs) {
        Map<String, List<String>> map = new HashMap<>();

        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);

            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);
        }

        return new ArrayList<>(map.values());
    }

    public static void main(String[] args) {
        List<String> strs = Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat");
        System.out.println(groupAnagrams(strs)); 
        // Output: [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
    }
}
```

---

### 6. **First Non-Repeated Character**
**Problem**:
Given a string, find the first non-repeating character. If there is no non-repeating character, return `-1`.

**Example**:
- Input: `"leetcode"`
- Output: `'l'`

### Approach:
- Use a `LinkedHashMap` to preserve the order of characters and count their occurrences.

**Solution**:
```java
import java.util.*;

public class FirstNonRepeatingCharacter {
    public static char firstUniqChar(String s) {
        Map<Character, Integer> map = new LinkedHashMap<>();
        
        // Count occurrences of each character
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        // Find the first character with count 1
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            if (entry.getValue() == 1) {
                return entry.getKey();
            }
        }
        
        return '-';  // Return '-' if no unique character exists
    }

    public static void main(String[] args) {
        String s = "leetcode";
        System.out.println(firstUniqChar(s)); // Output: 'l'
    }
}
```

---




### Conclusion:

These coding questions cover a variety of problems related to Java collections, including lists, sets, maps, and heaps. They test your ability to manipulate collections efficiently and implement common algorithms using the appropriate data structures.

Feel free to try these questions and let me know if you need help with solutions or further explanations. Happy coding!


###7  How do you find the frequency of each element in an ArrayList?


Here are some commonly asked Java interview questions focusing on the Collections framework. These questions range from basic concepts to more advanced applications and are designed to test your understanding of different collection classes, algorithms, and performance considerations.

---

### 1. **How do you remove duplicates from an ArrayList in Java?**

One way to remove duplicates from an `ArrayList` is to convert it into a `Set` and then back to an `ArrayList`, as `Set` does not allow duplicates.

```java
import java.util.*;

public class RemoveDuplicates {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 2, 3, 4, 4, 5));
        
        // Method 1: Using a HashSet
        List<Integer> uniqueList = new ArrayList<>(new HashSet<>(list));
        
        // Method 2: Using LinkedHashSet to maintain insertion order
        List<Integer> uniqueListOrdered = new ArrayList<>(new LinkedHashSet<>(list));
        
        System.out.println("Without duplicates: " + uniqueList);
        System.out.println("Without duplicates (maintained order): " + uniqueListOrdered);
    }
}
```

---

### 2. **How do you find the frequency of each element in an ArrayList?**

Use a `HashMap` to count the occurrences of each element.

```java
import java.util.*;

public class FrequencyCounter {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("apple", "banana", "apple", "orange", "banana", "apple");
        
        Map<String, Integer> frequencyMap = new HashMap<>();
        
        for (String item : list) {
            frequencyMap.put(item, frequencyMap.getOrDefault(item, 0) + 1);
        }
        
        System.out.println("Frequency of elements: " + frequencyMap);
    }
}
```

---

### 3. **How do you find the intersection of two lists in Java?**

You can use `retainAll` to find the intersection between two lists.

```java
import java.util.*;

public class IntersectionOfLists {
    public static void main(String[] args) {
        List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        List<Integer> list2 = new ArrayList<>(Arrays.asList(3, 4, 5, 6, 7));
        
        list1.retainAll(list2);
        
        System.out.println("Intersection: " + list1); // Output: [3, 4, 5]
    }
}
```

---

### 4. **How do you sort a `Map` by its values?**

You can use a `LinkedHashMap` to maintain insertion order after sorting by values.

```java
import java.util.*;
import java.util.stream.*;

public class SortMapByValue {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 3);
        map.put("banana", 1);
        map.put("orange", 2);
        
        Map<String, Integer> sortedMap = map.entrySet()
            .stream()
            .sorted(Map.Entry.comparingByValue())
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (e1, e2) -> e1,
                LinkedHashMap::new
            ));
        
        System.out.println("Map sorted by values: " + sortedMap);
    }
}
```

---

### 5. **How do you find the first non-repeating character in a string using collections?**

Use a `LinkedHashMap` to maintain insertion order and count occurrences.

```java
import java.util.*;

public class FirstNonRepeatingCharacter {
    public static void main(String[] args) {
        String str = "swiss";
        Map<Character, Integer> charCount = new LinkedHashMap<>();
        
        for (char c : str.toCharArray()) {
            charCount.put(c, charCount.getOrDefault(c, 0) + 1);
        }
        
        for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {
            if (entry.getValue() == 1) {
                System.out.println("First non-repeating character: " + entry.getKey());
                break;
            }
        }
    }
}
```

---

### 6. **How do you reverse a `List` in Java?**

You can use `Collections.reverse()` to reverse the elements of a list in place.

```java
import java.util.*;

public class ReverseList {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        Collections.reverse(list);
        
        System.out.println("Reversed list: " + list);
    }
}
```

---

### 7. **How do you implement a LRU Cache in Java using Collections?**

Use a `LinkedHashMap` with access order to implement an LRU Cache.

```java
import java.util.*;

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }

    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);
        cache.put(1, "one");
        cache.put(2, "two");
        cache.put(3, "three");
        cache.get(1); // Access element to move it to the most recent position
        cache.put(4, "four"); // This will evict key 2

        System.out.println(cache.keySet()); // Output: [3, 1, 4]
    }
}
```

---

### 8. **How do you convert a `List` of strings into a single comma-separated string?**

Use `String.join()` or Java Streams to concatenate list elements.

```java
import java.util.*;

public class ListToString {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("apple", "banana", "orange");
        
        String result = String.join(", ", list);
        System.out.println("Comma-separated string: " + result);
    }
}
```

---

### 9. **How do you find the maximum occurring element in an array using collections?**

Use a `HashMap` to count occurrences and find the maximum.

```java
import java.util.*;

public class MaxOccurringElement {
    public static void main(String[] args) {
        int[] arr = {1, 2, 2, 3, 3, 3, 4, 5};
        
        Map<Integer, Integer> countMap = new HashMap<>();
        
        for (int num : arr) {
            countMap.put(num, countMap.getOrDefault(num, 0) + 1);
        }
        
        int maxCount = 0;
        int maxElement = -1;
        
        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                maxElement = entry.getKey();
            }
        }
        
        System.out.println("Max occurring element: " + maxElement);
    }
}
```

---

### 10. **How do you shuffle elements in a `List` in Java?**

You can use `Collections.shuffle()` to randomly shuffle elements in a list.

```java
import java.util.*;

public class ShuffleList {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        Collections.shuffle(list);
        
        System.out.println("Shuffled list: " + list);
    }
}
```


Here are some Java coding questions that cover **Collections**, **Multithreading**, **Object-Oriented Programming (OOP)**, and **Exception Handling**. These questions will test various aspects of these topics.

---

### 1. **Collections Question**

**Question**: Write a Java program to find the top three most frequently occurring words in a list of strings. Use collections to store and process the data.

**Solution Outline**:
1. Use a `Map<String, Integer>` to store the frequency of each word.
2. Sort the entries in the map by value.
3. Retrieve the top three entries.

**Example**:
```java
import java.util.*;

public class TopThreeWords {
    public static List<String> findTopThreeWords(List<String> words) {
        Map<String, Integer> wordCount = new HashMap<>();
        
        // Count the frequency of each word
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        
        // Sort the map entries by frequency in descending order
        List<Map.Entry<String, Integer>> sortedEntries = new ArrayList<>(wordCount.entrySet());
        sortedEntries.sort((a, b) -> b.getValue().compareTo(a.getValue()));
        
        // Retrieve the top three words
        List<String> topThreeWords = new ArrayList<>();
        for (int i = 0; i < Math.min(3, sortedEntries.size()); i++) {
            topThreeWords.add(sortedEntries.get(i).getKey());
        }
        
        return topThreeWords;
    }

    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "apple", "orange", "banana", "apple", "grape", "grape");
        System.out.println(findTopThreeWords(words)); // Output example: [apple, banana, grape]
    }
}
```

---

### 2. **Multithreading Question**

**Question**: Create a Java program with two threads. The first thread prints numbers from 1 to 50, and the second thread prints numbers from 51 to 100. Ensure that both threads complete their tasks sequentially.

**Solution Outline**:
1. Use a `CountDownLatch` or `join()` to make sure the second thread only starts after the first thread completes.

**Example**:
```java
public class SequentialThreads {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 1; i <= 50; i++) {
                System.out.println("Thread 1: " + i);
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 51; i <= 100; i++) {
                System.out.println("Thread 2: " + i);
            }
        });

        try {
            t1.start();
            t1.join(); // Ensures t1 completes before t2 starts
            t2.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### 3. **Object-Oriented Programming (OOP) Question**

**Question**: Design a simple `BankAccount` class with methods to deposit, withdraw, and check balance. Include checks to prevent withdrawing more than the available balance.

**Solution Outline**:
1. Define fields for `balance`.
2. Define methods `deposit()`, `withdraw()`, and `getBalance()` with necessary validation.

**Example**:
```java
class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public synchronized void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        }
    }

    public synchronized void withdraw(double amount) {
        if (amount > balance) {
            System.out.println("Insufficient balance");
        } else {
            balance -= amount;
            System.out.println("Withdrew: " + amount);
        }
    }

    public double getBalance() {
        return balance;
    }

    public static void main(String[] args) {
        BankAccount account = new BankAccount(500);
        account.deposit(200);
        account.withdraw(100);
        account.withdraw(700); // Should display "Insufficient balance"
        System.out.println("Final Balance: " + account.getBalance());
    }
}
```

---

### 4. **Exception Handling Question**

**Question**: Write a Java method that reads an integer from the user and throws a custom exception if the number is negative. The custom exception should be named `NegativeNumberException`.

**Solution Outline**:
1. Create a custom exception `NegativeNumberException`.
2. Implement a method that reads a number, checks if it's negative, and throws the exception if necessary.

**Example**:
```java
import java.util.Scanner;

class NegativeNumberException extends Exception {
    public NegativeNumberException(String message) {
        super(message);
    }
}

public class NumberChecker {
    public static void checkPositiveNumber(int number) throws NegativeNumberException {
        if (number < 0) {
            throw new NegativeNumberException("Number is negative: " + number);
        } else {
            System.out.println("Number is positive: " + number);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int number = scanner.nextInt();

        try {
            checkPositiveNumber(number);
        } catch (NegativeNumberException e) {
            System.out.println("Caught exception: " + e.getMessage());
        }
    }
}
```

---

These examples cover the essentials of Collections, Multithreading, OOP, and Exception Handling in Java and provide a good foundation for tackling interview questions in these areas.

---

These questions cover a variety of Java Collection concepts and methods, from basic operations to more complex data manipulation tasks. Understanding these examples will help you perform well in coding interviews focusing on Java collections.



Here's a sample interview coding question on `ArrayList` for Java, including variations to challenge understanding of basic operations, algorithmic thinking, and edge cases.

---

### Problem 1: Remove Duplicates from an `ArrayList`
**Question**: Given an `ArrayList<Integer>`, write a function to remove all duplicate elements and return a list that contains only unique elements. Preserve the order of first occurrence.

#### Example
```java
Input: [1, 2, 2, 3, 4, 4, 5]
Output: [1, 2, 3, 4, 5]
```

#### Solution
This can be done by iterating through the list and checking each element's presence in a `Set`. If itâ€™s not in the set, add it to both the set and the result list.

```java
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;

public class RemoveDuplicates {
    public static List<Integer> removeDuplicates(List<Integer> list) {
        LinkedHashSet<Integer> set = new LinkedHashSet<>(list); // Preserves order of first occurrence
        return new ArrayList<>(set); // Convert the set back to an ArrayList
    }

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(List.of(1, 2, 2, 3, 4, 4, 5));
        System.out.println(removeDuplicates(list)); // Output: [1, 2, 3, 4, 5]
    }
}
```

---

### Problem 2: Find Common Elements in Two `ArrayLists`
**Question**: Write a function that takes two `ArrayList<Integer>` objects and returns an `ArrayList` containing their common elements. The result should not contain duplicates, even if both lists have duplicate values.

#### Example
```java
Input: list1 = [1, 2, 2, 3, 4], list2 = [2, 3, 3, 5]
Output: [2, 3]
```

#### Solution
Using a `Set` to collect common elements without duplicates is efficient. We can add one listâ€™s elements to a set, then filter by the second list.

```java
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class CommonElements {
    public static List<Integer> findCommonElements(List<Integer> list1, List<Integer> list2) {
        Set<Integer> set1 = new HashSet<>(list1);
        Set<Integer> commonElements = new HashSet<>();

        for (int num : list2) {
            if (set1.contains(num)) {
                commonElements.add(num);
            }
        }
        
        return new ArrayList<>(commonElements);
    }

    public static void main(String[] args) {
        ArrayList<Integer> list1 = new ArrayList<>(List.of(1, 2, 2, 3, 4));
        ArrayList<Integer> list2 = new ArrayList<>(List.of(2, 3, 3, 5));
        System.out.println(findCommonElements(list1, list2)); // Output: [2, 3]
    }
}
```

---

### Problem 3: Rotate an `ArrayList` to the Right by `k` Positions
**Question**: Given an `ArrayList<Integer>` and an integer `k`, rotate the list to the right by `k` positions. Handle cases where `k` is larger than the size of the list.

#### Example
```java
Input: list = [1, 2, 3, 4, 5], k = 2
Output: [4, 5, 1, 2, 3]
```

#### Solution
To rotate the list, find the point where it needs to be split (`n - k`), where `n` is the size of the list. Rearrange the list by reordering the two parts.

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class RotateList {
    public static List<Integer> rotateRight(List<Integer> list, int k) {
        int n = list.size();
        if (n == 0) return list; // Edge case: empty list
        
        k = k % n; // Handle cases where k > n
        if (k == 0) return list; // No rotation needed
        
        List<Integer> rotatedList = new ArrayList<>(list.subList(n - k, n));
        rotatedList.addAll(list.subList(0, n - k));
        return rotatedList;
    }

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(List.of(1, 2, 3, 4, 5));
        System.out.println(rotateRight(list, 2)); // Output: [4, 5, 1, 2, 3]
    }
}
```

---

### Problem 4: Find the Most Frequent Element in an `ArrayList`
**Question**: Write a function that takes an `ArrayList<Integer>` and returns the most frequently occurring element. If there are multiple elements with the same highest frequency, return any of them.

#### Example
```java
Input: [1, 3, 2, 3, 4, 3, 2, 2]
Output: 3
```

#### Solution
Use a `HashMap` to store the count of each element, then find the element with the highest frequency.

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MostFrequentElement {
    public static int findMostFrequent(List<Integer> list) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        
        // Count frequencies
        for (int num : list) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }
        
        // Find the most frequent element
        int mostFrequent = list.get(0);
        int maxCount = 0;
        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                mostFrequent = entry.getKey();
            }
        }
        
        return mostFrequent;
    }

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(List.of(1, 3, 2, 3, 4, 3, 2, 2));
        System.out.println(findMostFrequent(list)); // Output: 3
    }
}
```

---

### Problem 5: Remove All Occurrences of an Element in an `ArrayList`
**Question**: Write a function that removes all occurrences of a specified element from an `ArrayList<Integer>`, modifying the list in place.

#### Example
```java
Input: list = [1, 2, 2, 3, 4, 2], element = 2
Output: [1, 3, 4]
```

#### Solution
Use the `removeIf` method in Java 8+ to efficiently remove all occurrences of a specified element.

```java
import java.util.ArrayList;
import java.util.List;

public class RemoveOccurrences {
    public static void removeElement(List<Integer> list, int element) {
        list.removeIf(num -> num == element); // Removes all occurrences of `element`
    }

    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(List.of(1, 2, 2, 3, 4, 2));
        removeElement(list, 2);
        System.out.println(list); // Output: [1, 3, 4]
    }
}
```

These examples cover some typical operations on `ArrayList`, like removing duplicates, finding common elements, rotating, finding the most frequent element, and removing specific elements, each of which can help build understanding of `ArrayList` manipulation and edge case handling.



Here are the **detailed solutions and explanations** for all the Java array coding questions:

---

### **1. Reversing an Array**
```java
public class ReverseArray {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int n = arr.length;
        
        for (int i = 0; i < n / 2; i++) {
            int temp = arr[i];
            arr[i] = arr[n - i - 1];
            arr[n - i - 1] = temp;
        }
        
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```
**Explanation:**  
- Swap elements from start and end using a temporary variable.
- Iterate only till the middle of the array.

---

### **2. Find the Maximum and Minimum Elements in an Array**
```java
public class MinMaxArray {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 5, 40};
        int max = arr[0], min = arr[0];
        
        for (int num : arr) {
            if (num > max) max = num;
            if (num < min) min = num;
        }
        
        System.out.println("Max: " + max);
        System.out.println("Min: " + min);
    }
}
```
**Explanation:**  
- Iterate through the array, updating the `max` and `min` variables.

---

### **3. Check if an Array is Sorted**
```java
public class CheckSorted {
    public static boolean isSorted(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) return false;
        }
        return true;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(isSorted(arr));
    }
}
```
**Explanation:**  
- Check if every adjacent pair satisfies `arr[i] <= arr[i + 1]`.

---

### **4. Find the Sum of Elements in an Array**
```java
public class SumArray {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4};
        int sum = 0;
        
        for (int num : arr) {
            sum += num;
        }
        
        System.out.println("Sum: " + sum);
    }
}
```
**Explanation:**  
- Use a loop to add all elements to the `sum`.

---

### **5. Find Duplicate Elements in an Array**
```java
import java.util.HashSet;

public class FindDuplicates {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 2, 4, 5, 1};
        HashSet<Integer> seen = new HashSet<>();
        HashSet<Integer> duplicates = new HashSet<>();
        
        for (int num : arr) {
            if (!seen.add(num)) {
                duplicates.add(num);
            }
        }
        
        System.out.println("Duplicates: " + duplicates);
    }
}
```
**Explanation:**  
- Use a `HashSet` to track seen elements. If `add()` returns `false`, itâ€™s a duplicate.

---

### **6. Rotate an Array**
```java
import java.util.Arrays;

public class RotateArray {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int k = 2;  // Number of rotations
        int n = arr.length;
        k %= n;  // Handle cases where k > n

        reverse(arr, 0, n - 1);
        reverse(arr, 0, k - 1);
        reverse(arr, k, n - 1);

        System.out.println(Arrays.toString(arr));
    }

    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
}
```
**Explanation:**  
- Reverse the entire array, then reverse individual parts.

---

### **7. Merge Two Sorted Arrays**
```java
import java.util.Arrays;

public class MergeSortedArrays {
    public static void main(String[] args) {
        int[] arr1 = {1, 3, 5};
        int[] arr2 = {2, 4, 6};
        int[] result = new int[arr1.length + arr2.length];

        int i = 0, j = 0, k = 0;

        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] < arr2[j]) result[k++] = arr1[i++];
            else result[k++] = arr2[j++];
        }

        while (i < arr1.length) result[k++] = arr1[i++];
        while (j < arr2.length) result[k++] = arr2[j++];

        System.out.println(Arrays.toString(result));
    }
}
```
**Explanation:**  
- Use two pointers to merge arrays in sorted order.

---

### **8. Move Zeroes to the End**
```java
public class MoveZeroes {
    public static void main(String[] args) {
        int[] arr = {0, 1, 0, 3, 12};
        int pos = 0;

        for (int num : arr) {
            if (num != 0) arr[pos++] = num;
        }

        while (pos < arr.length) {
            arr[pos++] = 0;
        }

        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```
**Explanation:**  
- Move non-zero elements forward and fill the rest with zeros.

---

### **9. Find the Subarray with Maximum Sum (Kadane's Algorithm)**
```java
public class MaxSubarraySum {
    public static void main(String[] args) {
        int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int maxSum = Integer.MIN_VALUE, currentSum = 0;

        for (int num : arr) {
            currentSum = Math.max(num, currentSum + num);
            maxSum = Math.max(maxSum, currentSum);
        }

        System.out.println("Maximum Subarray Sum: " + maxSum);
    }
}
```
**Explanation:**  
- Maintain a running sum and reset it if it becomes negative.

---

### **10. Find the Missing Number in an Array**
```java
public class MissingNumber {
    public static void main(String[] args) {
        int[] arr = {1, 2, 4, 6, 3, 7, 8};
        int n = arr.length + 1;  // Including the missing number
        int totalSum = n * (n + 1) / 2;
        int arraySum = 0;

        for (int num : arr) {
            arraySum += num;
        }

        System.out.println("Missing Number: " + (totalSum - arraySum));
    }
}
```
**Explanation:**  
- Use the sum formula for `1 to n`.

---

### **11. Find All Pairs with a Given Sum**
```java
import java.util.HashSet;

public class PairsWithSum {
    public static void main(String[] args) {
        int[] arr = {2, 4, 3, 5, 6, 1, 7};
        int target = 8;
        HashSet<Integer> seen = new HashSet<>();

        for (int num : arr) {
            int complement = target - num;
            if (seen.contains(complement)) {
                System.out.println("(" + complement + ", " + num + ")");
            }
            seen.add(num);
        }
    }
}
```
**Explanation:**  
- Use a `HashSet` to track complements for the target sum.

---

### **12. Find the Majority Element**
```java
public class MajorityElement {
    public static void main(String[] args) {
        int[] arr = {3, 3, 4, 2, 4, 4, 2, 4, 4};
        int count = 0, candidate = -1;

        for (int num : arr) {
            if (count == 0) {
                candidate = num;
                count = 1;
            } else if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }

        // Verify candidate
        count = 0;
        for (int num : arr) {
            if (num == candidate) count++;
        }

        if (count > arr.length / 2) {
            System.out.println("Majority Element: " + candidate);
        } else {
            System.out.println("No Majority Element");
        }
    }
}
```
**Explanation:**  
- Use the Boyer-Moore Voting Algorithm.

---

Let me know if youâ€™d like further clarifications or enhancements! ðŸ˜Š



169. Majority Element
Solved
Easy
Topics
Companies
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than âŒŠn / 2âŒ‹ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 ```java
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer,Integer> mapCount =new HashMap<>();
        int majorityCount = nums.length/2;
        for(int num : nums){
            mapCount.put(num,mapCount.getOrDefault(num,0)+1);
          if(mapCount.get(num)>majorityCount){
               return num;
          }
        }

        return -1;

        
    }
}
```
392. Is Subsequence
Solved
Easy
Topics
Companies
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

 

Example 1:

Input: s = "abc", t = "ahbgdc"
Output: true
Example 2:

Input: s = "axc", t = "ahbgdc"
Output: false
 

Constraints:

0 <= s.length <= 100
0 <= t.length <= 104
s and t consist only of lowercase English letters.
 

Follow up: Suppose there are lots of incoming s, say s1, s2, ..., sk where k >= 109, and you want to check one by one to see if t has its subsequence. In this scenario, how would you change your code?

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i=0,j=0;
        while(j<s.length()&&i<t.length()){
             if(s.charAt(j)==t.charAt(i)){
                j++;
             }
            i++;
        }

        return j==s.length();
    }
}
```


# Valid Parenthesis
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
 

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

Example 3:

Input: s = "(]"

Output: false

Example 4:

Input: s = "([])"

Output: true

 ```java
class Solution {
    public boolean isValid(String s) {
        char []ch=s.toCharArray();
        Stack<Character> stack=new Stack<>();
        for(Character c : ch){
            if(c=='('||c=='['||c=='{') {
                stack.push(c);
            }
          else if(c==')'||c==']'||c=='}') {
                     if(stack.isEmpty())
                     {
                        return false;
                     }
               Character t = stack.peek();

               if(c==')'&&t=='('||c==']'&&t=='['||c=='}'&&t=='{')
               {
                stack.pop();
               }
              else{
                return false;
              }

            }



Hereâ€™s a list of Java 8 coding exercises to help you practice its key features:

---

### **1. Functional Interfaces and Lambda Expressions**
- Write a program to sort a list of strings using a lambda expression.
- Create a custom functional interface and implement it using a lambda expression.
- Filter a list of integers to only include even numbers using `Predicate`.

---

### **2. Streams API**
- Use streams to filter a list of strings to only include those with a specific prefix.
- Find the maximum and minimum number in a list using `Collectors` and streams.
- Convert a list of strings to uppercase using `map`.
- Count the number of strings in a list that start with a specific letter using `filter`.

---

### **3. Optional**
- Create a method that returns an `Optional` and demonstrate how to handle the absence of a value using `isPresent` or `ifPresent`.
- Use `orElse` and `orElseGet` to provide default values for an `Optional`.

---

### **4. Default and Static Methods in Interfaces**
- Create an interface with a default method. Implement the interface and call the default method.
- Add a static method to the interface and call it directly without creating an instance.

---

### **5. Method References**
- Replace a lambda expression with a method reference in a sorting operation.
- Use constructor references to create new objects from a list of strings.

---

### **6. Date and Time API**
- Create a program to display the current date, time, and time zone using `LocalDateTime` and `ZoneId`.
- Calculate the difference between two dates using `Duration` or `Period`.
- Parse and format a date using `DateTimeFormatter`.

---

### **7. Collectors**
- Group a list of strings by their length using `Collectors.groupingBy`.
- Concatenate all strings in a list using `Collectors.joining`.
- Partition a list of integers into odd and even using `Collectors.partitioningBy`.

---

### **8. Parallel Streams**
- Use a parallel stream to process a large list of numbers and find their squares.
- Compare the performance of a sequential stream and a parallel stream for a large dataset.

---

### **9. Custom Comparator with Lambda**
- Sort a list of employees by their age and then by name using a lambda expression.
- Implement a multi-level comparator for custom objects.

---

### **10. Map Enhancements**
- Use `computeIfAbsent` to add a default value to a map.
- Merge two maps using the `merge` method.
- Iterate through a map using the `forEach` method.

---

Would you like detailed solutions for any of these exercises?



        }
        return stack.isEmpty() ;
    }
}
```


8. Find the Index of the First Occurrence in a String
Solved
Easy
Topics
Companies
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

 

Example 1:

Input: haystack = "sadbutsad", needle = "sad"
Output: 0
Explanation: "sad" occurs at index 0 and 6.
The first occurrence is at index 0, so we return 0.
Example 2:

Input: haystack = "leetcode", needle = "leeto"
Output: -1
Explanation: "leeto" did not occur in "leetcode", so we return -1.


```java
class Solution {
    public int strStr(String haystack, String needle) {
          if(needle.isEmpty())
          {
            return 0;
          }
        return haystack.indexOf(needle);
    }
}
```




# first repeating character 
'''java
import java.util.LinkedHashMap;
import java.util.Map;

public class FirstNonRepeatingCharacter {
    public static void main(String[] args) {
        String input = "swiss";
        Character result = findFirstNonRepeatingCharacter(input);

        if (result != null) {
            System.out.println("First non-repeating character: " + result);
        } else {
            System.out.println("No non-repeating character found.");
        }
    }

    public static Character findFirstNonRepeatingCharacter(String str) {
        // Create a LinkedHashMap to maintain the order of characters
        Map<Character, Long> charCountMap = str.chars()
                .mapToObj(c -> (char) c)
                .collect(LinkedHashMap::new, 
                        (map, c) -> map.put(c, map.getOrDefault(c, 0L) + 1), 
                        Map::putAll);

        // Find the first character with a count of 1
        return charCountMap.entrySet().stream()
                .filter(entry -> entry.getValue() == 1)
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse(null);
    }
'''



Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

 

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
   Arrays.sort(strs);
   String s1 = strs[0];
   String s2 = strs[strs.length-1];
   int idx=0;
   while(idx<s1.length()&&idx<s2.length())
   {
    if(s1.charAt(idx)==s2.charAt(idx))
    {
        idx++;
      

    }
    else{
        break;
    }
   }

return s1.substring(0,idx);
     // System.out.println(s1.substring(0,idx));
    }
}
```
## Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space.
Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.
Example 1:

Input: s = "the sky is blue"
Output: "blue is sky the"


```java
class Solution {
    public String reverseWords(String s) {
     //   String[] str=s.split(" ");
       // StringBuilder sb = new StringBuilder();
      //  int j=0;
        // for(int i=str.length-1;i>=0;i--){
        //     if (!str[i].isEmpty()) {
          // sb.append(str[i]);
          // if(i!=0){
            //sb.append(" ");
          // }

          return Arrays.stream(s.trim().split("\\s+"))
          .reduce((a,b)->b+" "+a)
          .orElse("");
             
         
  //    return sb.toString().trim();  
    }
}
```


# Longest Common Prefix of Strings


```java
import java.lang.reflect.Array;
import java.util.Arrays;

public class LongestCommonPrefix {
    public static void main(String[] args) {
        String[] arr = { "geeksforgeeks", "geeks",
                "geek", "geezer" };
       System.out.println(LongestCommonPrefix.longestCommonPrefixInArray(arr));
    }
     public static String longestCommonPrefixInArray(String[] s){
         Arrays.sort(s);
        String first = s[0];
        String last = s[s.length-1];
        int minimum=Math.min(first.length(),last.length());
        int i=0;
        while(i<minimum&& first.charAt(i)==last.charAt(i)){
            i++;
        }
         return last.substring(0,i);
     }
}
```
